name: RECOVERY

on:
  workflow_dispatch:
    inputs:
      RECOVERY_URL:
        description: 'URL direta do recovery (.img ou .img.lz4)'
        required: true

jobs:
  build:
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout (v4)
        uses: actions/checkout@v4

      - name: Instalar dependências
        run: |
          sudo apt-get update
          sudo apt-get install -y lz4 curl unzip zip tar git file

      - name: Baixar recovery
        run: |
          set -e
          URL="${{ github.event.inputs.RECOVERY_URL }}"
          echo "Baixando: $URL"
          # Usa a flag -L para seguir redirecionamentos
          curl -L "$URL" -o recovery.bin
          file recovery.bin || true

          # Se for LZ4, descompacta; senão, renomeia
          if file recovery.bin | grep -qi "LZ4"; then
            echo "Detectado LZ4, descompactando..."
            lz4 -d recovery.bin recovery.img
          else
            mv recovery.bin recovery.img
          fi

          ls -lh recovery.img

          # Copia para o local onde o script2 procura (diretório de trabalho)
          # O arquivo r.img é o nome hardcoded esperado pelo script2.sh
          cp -f recovery.img r.img
          ls -lh r.img

      - name: Baixar magiskboot e posicionar no caminho correto
        run: |
          set -e
          # CORREÇÃO: Usando URL de download direto e estável para evitar erros de redirecionamento
          MAGISK_URL="https://github.com/topjohnwu/Magisk/releases/download/v27.0/Magisk-v27.0.apk"
          echo "Baixando Magisk.apk de: $MAGISK_URL"
          curl -L -o Magisk.apk "$MAGISK_URL"

          # Extrai o binário arm64 e transforma em executável
          unzip -j Magisk.apk lib/arm64-v8a/libmagiskboot.so -d .
          mv libmagiskboot.so magiskboot
          chmod +x magiskboot

          # REMOVIDA A LINHA DE CÓPIA DESNECESSÁRIA: 'cp magiskboot magiskboot'
          ls -l magiskboot

      - name: Rodar script1.sh
        run: |
          set -e
          chmod +x script1.sh script2.sh || true
          # O arquivo r.img está no mesmo diretório
          ./script1.sh r.img || ./script1.sh || true

      - name: Rodar script2.sh
        run: |
          set -e
          ./script2.sh

      - name: Coletar artefatos gerados
        run: |
          set -e
          mkdir -p output
          # Pega possíveis arquivos gerados no diretório de trabalho
          find . -maxdepth 1 -type f \( -name "*.img" -o -name "*.tar" -o -name "*.zip" \) -print -exec cp -f {} output/ \; || true
          # Se ainda não houver .tar para Odin, tenta criar a partir do primeiro IMG patchado
          if [ ! -f output/patched-recovery.tar ]; then
            IMG=$(ls -1 output/*patched*recovery*.img 2>/dev/null | head -n1 || true)
            if [ -n "$IMG" ]; then
              echo "Criando TAR para Odin a partir de: $IMG"
              # Cria o TAR a partir do arquivo IMG na pasta output
              tar --format=ustar -cvf output/patched-recovery.tar -C output/ "$(basename "$IMG")"
            fi
          fi
          ls -lh output || true

      - name: Upload patched recovery (v4)
        uses: actions/upload-artifact@v4
        with:
          name: patched-recovery
          path: output/*
          retention-days: 7
